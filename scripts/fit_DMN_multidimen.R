library(DirichletMultinomial)
library(lattice)
library(xtable)
library(tidyverse)

args = commandArgs(trailingOnly=TRUE)

# Rscript --vanilla /tscc/nfs/home/hsher/projects/oligoCLIP/scripts/fit_DMN_multidimen.R \
# /tscc/nfs/home/hsher/scratch/oligo_PE_iter5/DMN/table/oCLIP_10_1.tsv.gz \
# /tscc/projects/ps-yeolab4/software/skipper/1.0.0/bin/skipper/annotations/gencode.v38.annotation.k562_totalrna.gt1.tiled_partition.features.tsv.gz \
# /tscc/nfs/home/hsher/scratch/oligo_PE_iter5/DMN/output \
# oCLIP_10_1
# INPUTs
fl=args[1] #'/tscc/nfs/home/hsher/scratch/oligo_PE_iter4/internal_output/counts/genome/bgtables/internal/iter4.PRPF8.tsv.gz'
annotation = args[2]
basedir= args[3] #'/tscc/nfs/home/hsher/scratch/oligo_PE_iter4_PRPF8_internal'
out_stem = args[4] #'iter4.PRPF8.Rep1'
dir.create(basedir, showWarnings = FALSE, recursive = TRUE)

# fl = '/tscc/nfs/home/hsher/scratch/oligo_PE_iter5/DMN/table/oCLIP_10_1.tsv.gz'
# annotation = '/tscc/projects/ps-yeolab4/software/skipper/1.0.0/bin/skipper/annotations/gencode.v38.annotation.k562_totalrna.gt1.tiled_partition.features.tsv.gz'
# basedir='/tscc/nfs/home/hsher/scratch/oligo_PE_iter5/DMN/output'
# out_stem='oCLIP_10_1'

options(width=70, digits=2)
full <- TRUE ### TODO: change to TRUE
.qualitative <- DirichletMultinomial:::.qualitative
dev.off <- function(...) invisible(grDevices::dev.off(...))

min_component = 1
max_component = 50 #### How to estimate this?
component_gap = 5
min_read = 10 



count_df = read_tsv(fl)
sample_cols = colnames(count_df)
count_df$name=row.names(count_df)

print(head(count_df))
count_df = count_df[rowSums(count_df[,sample_cols])>min_read, ]
count <- as.matrix(count_df[, sample_cols]) 
print('count matrix nrows=')
print(nrow(count))

print('count matrix ncol=')
print(ncol(count))

# sample rows
################ MODEL SELECTION: SAMPLING ################
# sampled_counts = count[sample(nrow(count),size=500,replace=FALSE),]

# library(parallel)
# if (full) {
# sample_fit <- mclapply(seq(min_component, max_component, component_gap), dmn, count=sampled_counts, verbose=TRUE)
# save(sample_fit, file=file.path(basedir, paste0(out_stem, ".sample_fit.rda")))
# } else load(file = file.path(basedir, paste0(out_stem, ".sample_fit.rda")))

# # plot Laplace against k
# lplc <- sapply(sample_fit, laplace)
# aic <- sapply(sample_fit, AIC)
# bic <- sapply(sample_fit, BIC)
#  pdf(file.path(basedir, paste0(out_stem, ".goodness_of_sample_fit.pdf")))
#  plot(aic, type="b", xlab="Number of Dirichlet Components(k)",ylab="AIC")
#  plot(bic, type="b", xlab="Number of Dirichlet Components(k)",ylab="BIC")
#  plot(lplc, type="b", xlab="Number of Dirichlet Components(k)",ylab="Model Fit(Laplace)")
#  dev.off()

#   # find the best model: the DMN object
#  (best <- sample_fit[[which.min(lplc)]])

################ MODEL SELECTION ################

# fit data k=1 to max_component, using a subset of data
library(parallel)
library(parallel)
cores = detectCores()
if (full) {
fit <- mclapply(seq(min_component, max_component, component_gap), dmn, count=count, verbose=TRUE, mc.cores = cores)
save(fit, file=file.path(basedir, paste0(out_stem, ".fit.rda")))
} else load(file = file.path(basedir, paste0(out_stem, ".fit.rda")))





# plot Laplace against k
lplc <- sapply(fit, laplace)
aic <- sapply(fit, AIC)
bic <- sapply(fit, BIC)
 pdf(file.path(basedir, paste0(out_stem, ".goodness_of_fit.pdf")))
 plot(aic, type="b", xlab="Number of Dirichlet Components(k)",ylab="AIC")
 plot(bic, type="b", xlab="Number of Dirichlet Components(k)",ylab="BIC")
 plot(lplc, type="b", xlab="Number of Dirichlet Components(k)",ylab="Model Fit(Laplace)")
 dev.off()

  # find the best model: the DMN object
 (best <- fit[[which.min(aic)]]) ## better estimation of binding score!

################ CLUSTER SIZE ################
# reports the weight $\pi$ and $\theta$
# theta = \sum alphas, higher, more concentrated cluster
weights = mixturewt(best)
write_tsv(data.frame(weights) %>% rownames_to_column(), file.path(basedir, paste0(out_stem, '.weights.tsv')))

################ CLUSTER LABELLING ################
# contribution of each taxonomic group to the Dirichlet components
# fitted https://rdrr.io/bioc/DirichletMultinomial/man/fitted.html
fitted_df = data.frame(fitted(best, assign = FALSE))%>% rownames_to_column()
write_tsv(fitted_df, file.path(basedir, paste0(out_stem, '.alpha.tsv')))

# write null
fitted_df_null = data.frame(fitted(fit[[1]], assign = FALSE))%>% rownames_to_column()
names(fitted_df_null) <- c('rowname', 'single_component_weight')
write_tsv(fitted_df_null, file.path(basedir, paste0(out_stem, '.null.alpha.tsv')))

# how does the model differ from a single component DMN
p0 <- fitted(fit[[1]], scale=TRUE) # scale by theta
p_best <- fitted(best, scale=TRUE)
colnames(p_best) <- paste("m", 1:ncol(p_best), sep="")
(meandiff <- colSums(abs(p_best - as.vector(p0)))) # the difference of each component to 1 single component (possibly the null)

# export the component
mixture_df = mixture(best, assign = FALSE) # sample by component matrix
row.names(mixture_df) <- count_df$name

# join annotation
anno_df = read_tsv(annotation)
annotated_mixture=merge(mixture_df, anno_df, by.x='row.names', by.y='name')

write_tsv(data.frame(annotated_mixture) %>% rownames_to_column(), file.path(basedir, paste0(out_stem,'.mixture_weight.tsv')))

